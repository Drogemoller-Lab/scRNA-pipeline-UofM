---
title: "scRNA/Multiome Pipeline Analyses"
author:   
  - John Pham   
  - Deanne Nixie Miao
  - Dr. Britt Drögemöller
  - Dr. Galen Wright
format:
  html:
    toc_float: yes
    toc-depth: 5
    collapse: true
    toc-location: left
    self-contained: true
    embed-resources: true
    code-tools: true
editor: visual
toc: true
date: today
params:
  data: ""
---

```{r}
#| echo: false
#res.loc <- "/research/2024_scrnaseq_pipeline/summary_report_ex/"
res.loc <- params$data
```

```{r}
#| label: r-libraries
#| echo: false
#| output: false
library(knitr)
library(base64enc)
library(data.table)
library(dplyr)
library(tidyverse)
library(Seurat)
library(glue)
```

```{r}
#| label: r-functions
#| echo: false
read_jpegs <- function(path, pattern) {
  jpeg_files <- list.files(path = path, pattern = pattern, full.names = TRUE, recursive = T)
  list(files = basename(jpeg_files), paths = jpeg_files)
}

generate_html <- function(jpeg_data) {
  # Generate dropdown options
  select_html <- paste0(
    '<option value="', jpeg_data$files, '">', jpeg_data$files, '</option>',
    collapse = "\n"
  )
  
  # Generate divs with embedded JPEG content
  divs_html <- paste0(
    '<div id="', jpeg_data$files, '" style="display: none;">',
    '<img src="', jpeg_data$paths, '" width="100%" height="100%" alt="', jpeg_data$files, '">',
    '</div>',
    collapse = "\n"
  )
  
  list(select_html = select_html, divs_html = divs_html)
}

process_jpegs_conditional <- function(path, pattern) {
  jpeg_files <- list.files(path = path, pattern = pattern, full.names = TRUE, recursive = T)
  if (length(jpeg_files) == 0) {
    return(NULL)
  }
  jpeg_data <- list(
    files = basename(jpeg_files),
    paths = jpeg_files
  )
  generate_html(jpeg_data)
}

generate_dropdown <- function(dropdown_id, dropdown_content) {
  html <- glue::glue(
    '<div>
      <label for="{dropdown_id}">Select a Plot:</label>
      <select id="{dropdown_id}">
        {dropdown_content$select_html}
      </select>
    </div>
    
    <div id="container-{dropdown_id}">
      {dropdown_content$divs_html}
    </div>
    
    <script>setupDropdown("{dropdown_id}", "container-{dropdown_id}");</script>'
  )
  html
}

```

```{=html}

<script>
  // Setup Dropdown Function
  function setupDropdown(dropdownId, containerId) {
    const selectElement = document.getElementById(dropdownId);
    const container = document.getElementById(containerId);

    // Add event listener for plot visibility toggle
    selectElement.addEventListener('change', function() {
      const selectedPlot = this.value;
      const plots = container.querySelectorAll('div');
      plots.forEach(plot => {
        plot.style.display = plot.id === selectedPlot ? 'block' : 'none';
      });
    });

    // Display the first plot by default
    const plots = container.querySelectorAll('div');
    if (plots.length > 0) {
      selectElement.value = plots[0].id;
      plots[0].style.display = 'block';
    }
  }
</script>
```
```{r}
#| echo: false
#| label: r-plotlocations-setup

# Define paths and patterns
## QC plots
path_qc <- paste0(res.loc,"/plots/qc/")
pattern_1 <- "\\percent_mt.jpeg$"
pattern_2 <- "\\UMI.jpeg$"
pattern_3 <- "\\count_atac.jpeg$"
pattern_4 <- "\\_tss.jpeg$"
pattern_4_1 <- "\\_nucleosome_signal.jpeg$"

## Seurat processing
path_seurat <- paste0(res.loc,"/plots/")
pattern_5 <- "\\umap_unlabelled.jpeg$"
pattern_6 <- "\\cells_group_unlabelled.jpeg$"
pattern_7 <- "\\umap_labelled.jpeg$"
pattern_8 <- "\\umap_split.jpeg$"

## Cell marker
pattern_9 <- "\\markers_expr_heatmap.jpeg$"
pattern_10 <- "\\rved_marker_unlabelled.pdf.jpeg$"
pattern_11 <- "\\marker_mapping_heatmap.jpeg$"
pattern_12 <- "\\cent_cells_group_labelled.jpeg$"

## DESeq2
path_deseq2 <- paste0(res.loc,"/plots/deseq2/") 
pattern_13 <- "^deseq2.*\\.jpeg$"

## GSEA
path_gsea <- paste0(res.loc,"/plots/gsea/comparative/") 
pattern_14 <- "^gsea.*\\.jpeg$"

## escape
path_escape <- paste0(res.loc,"/plots/gsea/escape/") 
pattern_15 <- "^escape_heatmap.*\\.jpeg$"
pattern_16 <- "\\geyser.jpeg$"

## slingshot
path_slingshot <- paste0(res.loc,"/plots/ti/") 
pattern_17 <- "\\_smooth.jpeg$"
pattern_18 <- "\\_deg_between_group.jpeg$"
pattern_19 <- "^ti_de_slingPseudotime.*\\.jpeg$"

## psupertime
path_psuper <- paste0(res.loc,"/plots/ti/psupertime_plots/") 
pattern_20 <- "^psuper_density_pseudotime.*\\.jpeg$"
pattern_21 <- "^psuper_gene_coefficients.*\\.jpeg$"
pattern_22 <- "^psuper_top_20_genes.*\\.jpeg$"
pattern_23 <- "^psuper_boxplot_compare_dist.*\\.jpeg$"

## da
path_da <- paste0(res.loc,"/plots/da/") 
pattern_24 <- "^milo_pval_distribution.*\\.jpeg$"
pattern_25 <- "^milo_volcano_plot.*\\.jpeg$"
pattern_26 <- "^milo_DA_umap.*\\.jpeg$"
pattern_27 <- "^milo_DA_fc_distribution.*\\.jpeg$"
pattern_28 <- "^milo_DA_DE_heatmap.*\\.jpeg$"
pattern_29 <- "^milo_gsea.*\\.jpeg$"

## neuroestimator
path_neuro <- paste0(res.loc,"/plots/neuroestimator/") 
pattern_30 <- "^neuroestimator.*\\.jpeg$"

# Generate dropdown and divs for two different sets of jpeg files
## QC plots
dropdown_1 <- process_jpegs_conditional(path_qc, pattern_1)
dropdown_2 <- process_jpegs_conditional(path_qc, pattern_2)

dropdown_3 <- process_jpegs_conditional(path_qc, pattern_3)
dropdown_3_exists <- !is.null(dropdown_3)

dropdown_4 <- process_jpegs_conditional(path_qc, pattern_4)
dropdown_4_exists <- !is.null(dropdown_4)

dropdown_4_1 <- process_jpegs_conditional(path_qc, pattern_4_1)
dropdown_4_1_exists <- !is.null(dropdown_4_1)

## Seurat processing plots
dropdown_5 <- process_jpegs_conditional(path_seurat, pattern_5)
dropdown_6 <- process_jpegs_conditional(path_seurat, pattern_6)
dropdown_7 <- process_jpegs_conditional(path_seurat, pattern_7)
dropdown_8 <- process_jpegs_conditional(path_seurat, pattern_8)

## Cell marker plots
dropdown_9 <- process_jpegs_conditional(path_seurat, pattern_9)
dropdown_10 <- process_jpegs_conditional(path_seurat, pattern_10)
dropdown_11 <- process_jpegs_conditional(path_seurat, pattern_11)
dropdown_12 <- process_jpegs_conditional(path_seurat, pattern_12)

## DESeq2
dropdown_13 <- process_jpegs_conditional(path_deseq2, pattern_13)

## GSEA
dropdown_14 <- process_jpegs_conditional(path_gsea, pattern_14)

## escape plots
dropdown_15 <- process_jpegs_conditional(path_escape, pattern_15)
dropdown_15_exists <- !is.null(dropdown_15)

dropdown_16 <- process_jpegs_conditional(path_escape, pattern_16)
dropdown_16_exists <- !is.null(dropdown_16)


## slingshot plots
dropdown_17 <- process_jpegs_conditional(path_slingshot, pattern_17)
dropdown_17_exists <- !is.null(dropdown_17)

dropdown_18 <- process_jpegs_conditional(path_slingshot, pattern_18)
dropdown_18_exists <- !is.null(dropdown_18)

dropdown_19 <- process_jpegs_conditional(path_slingshot, pattern_19)
dropdown_19_exists <- !is.null(dropdown_19)


## psupertime plots
dropdown_20 <- process_jpegs_conditional(path_psuper, pattern_20)
dropdown_21 <- process_jpegs_conditional(path_psuper, pattern_21)
dropdown_22 <- process_jpegs_conditional(path_psuper, pattern_22)
dropdown_23 <- process_jpegs_conditional(path_psuper, pattern_23)
dropdown_23_exists <- !is.null(dropdown_23)

## da plots
dropdown_24 <- process_jpegs_conditional(path_da, pattern_24)
dropdown_24_exists <- !is.null(dropdown_24)

dropdown_25 <- process_jpegs_conditional(path_da, pattern_25)
dropdown_25_exists <- !is.null(dropdown_25)

dropdown_26 <- process_jpegs_conditional(path_da, pattern_26)
dropdown_26_exists <- !is.null(dropdown_26)

dropdown_27 <- process_jpegs_conditional(path_da, pattern_27)
dropdown_27_exists <- !is.null(dropdown_27)

dropdown_28 <- process_jpegs_conditional(path_da, pattern_28)
dropdown_28_exists <- !is.null(dropdown_28)

dropdown_29 <- process_jpegs_conditional(path_da, pattern_29)
dropdown_29_exists <- !is.null(dropdown_29)

dropdown_30 <- process_jpegs_conditional(path_neuro, pattern_30)
dropdown_30_exists <- !is.null(dropdown_30)
```

# Quality Control

Quality control (QC) is the process of evaluating and filtering data to ensure accuracy and reliability for downstream analyses. It involves identifying and removing low-quality nuclei/cells, doublets, and contamination from ambient RNA while addressing technical artifacts like batch effects.

The original amount of cells and the amount after (QC) is shown in the table below. Please view each analysis in the QC section for more info on how they were selected.

```{r}
#| label: r-total-cells-table
#| echo: false

qc.table <- data.frame()

# loading in raw list -> get the original cell count
se.raw <- readRDS(paste0(res.loc, "/data/se_list_raw.rds"))

# loading in list after all QC steps are done
se.filtered.singlets <- readRDS(paste0(res.loc, "/data/se_filtered_singlets_list.rds"))

for (i in 1:length(se.filtered.singlets)) {
  filtered <- nrow(se.filtered.singlets[[i]]@meta.data)
  raw <- nrow(se.raw[[i]]@meta.data)
  
  # Add a row for the current dataset
  current_ident <- unique(se.filtered.singlets[[i]]@meta.data[["ident"]])
  qc.table <- rbind(qc.table, data.frame(ident = current_ident, raw = raw, filtered = filtered))
}

# Set 'ident' as the row names and drop the column
rownames(qc.table) <- qc.table$ident
qc.table <- qc.table[, -1]

# Display the table
kable(qc.table, caption = "Total filtered cells from QC metrics")
```

## Ambient RNA Correction

Ambient RNA refers to RNA molecules present in the extracellular environment that do not originate from the nuclei/cells being analyzed. This RNA is often introduced during sample preparation, typically from lysed cells or other cellular debris, and can be inadvertently captured during sequencing.

soupX is the tool used in this pipeline to remove the ambient RNA.

```{r}
#| label: r-ambient-code
#| echo: true
#| eval: false
#| code-fold: true

#' Perform ambient RNA correction using soupX over
#' 
#' @param matriceList List that contains the filtered and raw matrices from 
#' Cellranger data
#' @param downsampleNum Denotes the number to downsample the counts matrix
#'
#' @return Folder with the given sample name, with the corrected counts
#' 
AmbientRNARemoval <- function(matriceList, 
                              downsampleNum
                              ) {

  print(paste("Loading ", matriceList[1], " and ", matriceList[2], sep=''))
  
  # check if it is a multiome experiment format
  filt.matrix <- Read10X_h5(matriceList[1],use.names = T)
  raw.matrix <- Read10X_h5(matriceList[2],use.names = T)
  
  if (!is.list(filt.matrix)){
    se <- CreateSeuratObject(counts = filt.matrix) # create seurat object
    
    print("Providing Soup")
    soup.channel <- SoupChannel(raw.matrix, filt.matrix)   # soup channel stpres all info related to a single 10X channel
  } else {
    se <- CreateSeuratObject(counts = filt.matrix$`Gene Expression`) # create seurat object
    
    print("Providing Soup multiome")
    soup.channel <- SoupChannel(raw.matrix$`Gene Expression`, filt.matrix$`Gene Expression`)   # soup channel stpres all info related to a single 10X channel
  }
  
  # Quickly perform clustering -> not looking for optimal clustering since this is a filtering step
  # Reports to have better results if some basic clustering is provided, even with basic seurat clustering
  print("Clustering")
  se <- SCTransform(se, verbose = F) # replaces NormalizeData, ScaleData, and FindVariableFeatures
  se <- RunPCA(se, verbose = F) # dimensional reduction
  se <- RunUMAP(se, dims = 1:30, verbose = F)
  se <- FindNeighbors(se, dims = 1:30, verbose = F)
  se <- FindClusters(se, verbose = T)
  
  meta  <- se@meta.data
  umap  <- se@reductions$umap@cell.embeddings
  soup.channel <- setClusters(soup.channel, setNames(meta$seurat_clusters, rownames(meta)))
  soup.channel <- setDR(soup.channel, umap) # used for visualizations if wanted; could remove
  
  print("Writing")
  soup.channel  <- autoEstCont(soup.channel, doPlot=FALSE)   # automatically estimates the contamination fraction
  adj.matrix  <- adjustCounts(soup.channel, roundToInt = T)   # calculate the resulting corrected count matrix with background contamination removed
  
  if(downsampleNum != 0){
    rand =  sample(1:ncol(adj.matrix), downsampleNum)
    adj.matrix = adj.matrix[, rand]
  }
  
  # should work with cellranger outputs -> just back tracks a set amount of times, so as long as folder struc is correct
  sample.name <- sub(".*\\/(.*)\\/.*\\/.*", "\\1", matriceList[1])
  group.name <- sub(".*\\/(.*)\\/.*\\/.*\\/.*", "\\1", matriceList[1])
  dir.create(paste0("./qc/"))
  dir.create(paste0("./qc/", group.name))
  
  print(paste("Saving under ./qc/", group.name, '/', sample.name, "_soupx",sep=''))
  DropletUtils:::write10xCounts(paste('./qc/', group.name, '/', sample.name, "_soupx",sep=''), adj.matrix, overwrite = TRUE) # name will be the fo;der before the /outs/ folder
}
```

## Filtering Low Quality Cells

Low quality nuclei/cells were identified based on their mitochondrial

### Percent mitochondrial

Filtered by the percentage of mitochondrial reads in the cell. A high amount usually denotes a lysed cell. Also, in single-nuclei experiment, the cutoff is expected to be much lower.

The minimum cutoff is set at 1% and can manually be set using `--mitochondrial_percent_cutoff [INT]`

```{=html}
<div>
  <label for="dropdown-1">Select a Plot:</label>
  <select id="dropdown-1">
    `r dropdown_1$select_html`
  </select>
</div>

<div id="container-1">
  `r dropdown_1$divs_html`
</div>

<script>setupDropdown('dropdown-1', 'container-1');</script>
```
### Genes and nUMI

Filtering by the number of genes and number of UMIs. A high amount of either/both signifies a possible multiplet, and a low amount shows lysed or ambient RNA that was caught in a droplet.

```{=html}
<div>
  <label for="dropdown-2">Select a Plot:</label>
  <select id="dropdown-2">
    `r dropdown_2$select_html`
  </select>
</div>

<div id="container-2">
  `r dropdown_2$divs_html`
</div>

<script>setupDropdown('dropdown-2', 'container-2');</script>
```
### Doublet removal

Doublet identification and removal is important because they can be easily mistaken as singlets, but with just high gene expression. To remove them, we use scDblFinder which uses a clustering method to separate doublets and singlets

```{r}
#| label: r-code-doublets
#| eval: false
#| echo: true
#| code-fold: true

#' Identify doublets using scDblFinder
#' 
#' @param seuratObj A seurat object  
#' @param atac Boolean true or false if data is multiomic
#'
#' @return Seurat object with metadata denoting singlets or doublets for each cell
#' 
DoubletQC <- function(seuratObj, atac){
  sce <- as.SingleCellExperiment(seuratObj)
  sce <- scDblFinder(sce, clusters=FALSE) # generates random doublets -> generates a new PCA -> creates a kNN network
  # training an iterative classifier on the neighborhood of real cells and artificial doublets

  se <- as.Seurat(sce, counts = "counts", data = NULL)
  
  if (atac == "yes"){
    se[["ATAC"]] <- seuratObj[["ATAC"]]
  }
  return(se)
}
```

```{r}
#| label: r-tbl-doublets
#| tbl-cap: "Doublet identification"
#| tbl-colwidths: [60,40]
#| echo: false

# Initialize an empty data frame to store results
doub.table <- data.frame()

# Populate the table
se.filtered.doublets.list <- readRDS(paste0(res.loc, "/data/se_filtered_doublets_list.rds"))
for (i in 1:length(se.filtered.doublets.list)) {
  singlets <- subset(se.filtered.doublets.list[[i]], subset = scDblFinder.class == "singlet") %>% colnames() %>% length()
  doublets <- subset(se.filtered.doublets.list[[i]], subset = scDblFinder.class == "doublet") %>% colnames() %>% length()
  
  # Add a row for the current dataset
  current_ident <- unique(se.filtered.doublets.list[[i]]@meta.data[["ident"]])
  doub.table <- rbind(doub.table, data.frame(ident = current_ident, singlet = singlets, doublet = doublets))
}

# Set 'ident' as the row names and drop the column
rownames(doub.table) <- doub.table$ident
doub.table <- doub.table[, -1]

# Display the table
kable(doub.table, caption = "Number of Doublets Detected with scDblFinder")

```

```{r}
#| label: r-check-atacqc
#| results: asis
#| echo: false
if (dropdown_3_exists && dropdown_4_exists) {
  cat(glue("
    ### scATAC
    
    There are additional QC steps for multiome experiments, to ensure that the scATAC-seq data is also of high-quality
  "))
}
if (dropdown_3_exists) {
  cat(glue("
    #### nCount ATAC
    
    If there are to few reads, they should be excluded due to low sequencing depth. If there are too many reads, it can represent doublets, nuclei clumps, etc. and should be removed as well
  "))
}
```

```{=html}
<div id="dropdown-3-container" style="`r if (dropdown_3_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-3">Select a Special Plot:</label>
  <select id="dropdown-3">
    `r if (dropdown_3_exists) dropdown_3$select_html else ""`
  </select>
</div>

<div id="container-3" style="`r if (dropdown_3_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_3_exists) dropdown_3$divs_html else ""`
</div>

<script>
    setupDropdown('dropdown-3', 'container-3');
</script>
```
```{r}
#| results: asis
#| echo: false
if (dropdown_4_exists) {
  cat(glue("
  #### Transcriptional start site (TSS) enrichment score

  Based on the ENCODE project's ATAC-seq scores. This is calculated by the 
  fragment ratio at the center of the TSS compared to the flanking regions.

  Higher enrichment scores are expected to be around the TSS, and a good 
  experiment is expected to have a high score overall.
  "))
}
```

```{=html}
<div id="dropdown-4-container" style="`r if (dropdown_4_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-4">Select a Special Plot:</label>
  <select id="dropdown-4">
    `r if (dropdown_4_exists) dropdown_4$select_html else ""`
  </select>
</div>

<div id="container-4" style="`r if (dropdown_4_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_4_exists) dropdown_4$divs_html else ""`
</div>

<script>
    setupDropdown('dropdown-4', 'container-4');
</script>
```
```{r}
#| results: asis
#| echo: false
if (dropdown_4_1_exists) {
  cat(glue("
  #### Nucleosome signal
  
  Filters the ratio of mono-nucleosomal to nucleosome-free fragments, also known as a signal-to-noise ratio. Expect to see general decrease in peaks.
  "))
}
```

```{=html}
<div id="dropdown-4_1-container" style="`r if (dropdown_4_1_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-4_1">Select a Special Plot:</label>
  <select id="dropdown-4_1">
    `r if (dropdown_4_1_exists) dropdown_4_1$select_html else ""`
  </select>
</div>

<div id="container-4_1" style="`r if (dropdown_4_1_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_4_1_exists) dropdown_4_1$divs_html else ""`
</div>

<script>
    setupDropdown('dropdown-4_1', 'container-4_1');
</script>
```
# Seurat processing

## Integration

The data undergoes typical seurat processing, following this [workflow](https://satijalab.org/seurat/articles/pbmc3k_tutorial). This involves normalization, identifying highly variable features, and scaling the data. Afterwards, linear dimensional reduction is performed (RunPCA), the data is clustered (FindClusters), and visualized using a UMAP (RunUMAP).

The UMAPs below are unlabeled but should be checked for proper integration or by your expectations.
Is it strictly clustered by condition? Are the cells clustered by sample?

```{r}
#| echo: false
knitr::include_graphics(paste0(path_seurat, "integrated_umap_unlabelled.jpeg"))
```

```{r}
#| echo: false
knitr::include_graphics(paste0(path_seurat, "integrated_umap_grouped.jpeg"))
```

```{r}
#| echo: false
knitr::include_graphics(paste0(path_seurat, "integrated_umap_split.jpeg"))
```

```{r}
#| echo: false
knitr::include_graphics(paste0(path_seurat, "percent_cells_group_unlabelled.jpeg"))
```

The number of clusters can vary depending on the resolution parameter set during analysis (default value is 1). Further, clusters can be further sub-clustered to determine if cells within a cluster can be classified into more specific sub-populations.

### Identifying cell markers

Top 3 differentially expressed genes (DEGs) from each cluster from the FindAllMarkers call in seurat. The wilcox rank sum test implementation from presto is used. Please visit the seurat documentation for more information.

```{r}
#| echo: false
knitr::include_graphics(paste0(path_seurat, "top3_markers_expr_heatmap.jpeg"))
```

Conserved markers between your main condition that is being test.

```{r}
#| echo: false
knitr::include_graphics(paste0(path_seurat, "conserved_marker_unlabelled.jpeg"))
```

```{r}
#| results: asis
#| echo: false
if (file.exists(paste0(path_seurat,"reference_marker_mapping_heatmap.jpeg"))) {
  cat(glue("
  ### Automatic cell-labelling
  
  If you provided a reference seurat object via `--reference_seurat` (.rds), the unlabeled clusters will be labeled accordingly with the TransferData function in Seurat. Please ensure that your seurat object's active.ident is set to the desired celltype metadata.
  "))
}
```

```{r}
#| results: asis
#| echo: false
if(file.exists(paste0(path_seurat,"reference_marker_mapping_heatmap.jpeg"))) {
  cat(paste('#### Automatic clustering labelling'))
}
```

This heatmap shows the prediction scores that was found using the FindTransferAnchors function in Seurat, displaying which of your unlabeled clusters have the highest similarity to the reference that you provided.

```{r}
#| echo: false
if(file.exists(paste0(path_seurat,"reference_marker_mapping_heatmap.jpeg"))) {
  knitr::include_graphics(paste0(path_seurat, "reference_marker_mapping_heatmap.jpeg"))
}
```

```{r}
#| echo: false
if(file.exists(paste0(path_seurat,"integrated_umap_labelled.jpeg"))) {
  knitr::include_graphics(paste0(path_seurat, "integrated_umap_labelled.jpeg"))
}
```

```{r}
#| echo: false
if(file.exists(paste0(path_seurat,"percent_cells_group_labelled.jpeg"))) {
  knitr::include_graphics(paste0(path_seurat, "percent_cells_group_labelled.jpeg"))
}
```

# Downstream analyses

## Pseudo-bulk analyses

### Differential gene expression analysis

Tool(s): DESeq2
Todo: Need to use pretty volcano plots package instead like the one used in the bulk pipeline

Differential gene expression analysis identifies genes that are expressed differently between experimental conditions. The volcano plots below show genes that are upregulated (red), downregulated (blue), or that are non-significant (gray). Remember that these statements are always relative to the conditions listed.

```{=html}
<div>
  <label for="dropdown-13">Select a Plot:</label>
  <select id="dropdown-13">
    `r dropdown_13$select_html`
  </select>
</div>

<div id="container-13">
  `r dropdown_13$divs_html`
</div>

<script>setupDropdown('dropdown-13', 'container-13');</script>
```
### Gene-set enrichment analysis (GSEA)

Tool(s): fgsea
Todo:Need to fix titles and sizing issues

GSEA involves identifying biological pathways or functional gene sets. The approach taken here uses a ranked-list, so we take all DESeq2 results above (including the non-significant) sort it by the log2FC values. 

```{=html}
<div>
  <label for="dropdown-14">Select a Plot:</label>
  <select id="dropdown-14">
    `r dropdown_14$select_html`
  </select>
</div>

<div id="container-14">
  `r dropdown_14$divs_html`
</div>

<script>setupDropdown('dropdown-14', 'container-14');</script>
```
```{r}
#| label: r-scatac-descriptions
#| results: asis
#| echo: false
path_scatac <- paste0(res.loc, "/plots/dap_plots/")

if (dir.exists(path_scatac)) {
  cat(glue("
  ## scATAC analyses
  
  There are several scATAC analyses that are referenced from [Signac](https://stuartlab.org/signac/). Below is a description of each plot.
  
  <ins>Differentially accessible peaks (DAPs) volcano plot:</ins>
  Similar to finding differentially expressed genes; uses the Wilcoxon rank sum test.
  
  In the next plots that state the closest genes, this is determined by taking the top 5 up- or down-regulated DAPs from the volcano plot and finding the closest genes to these them. 
  
  <ins>Closest genes to the DAPs, gene expression:</ins>
  Displays the normalized gene expression distribution.
  
  <ins>Closest genes to the DAPs, gene-set enrichment analysis:</ins>
  Again, similar to the GSEA done on the differentially expressed genes, will take all the genes and rank them by their logFC values.
  
  <ins>Closest genes to the DAPs, coverage:</ins>
  Displays the signal, expression, peaks, and peak linkages in a genome browser like view.
  
  <ins>Overrepresented Motifs:</ins>
  Signac can identify overrepresented motifs by filtering for significant DAPs (adjusted p-value < 0.05) and for each given condition (based off logFC and percentage expressed). Only the top 6 are plotted, and the full list can be found in the data directory.
  
  "))
}
```

```{r}
#| label: r-scatac-plots
#| echo: false

# Patterns
patterns <- list(
  scatac_volcano = "^scatac_volcano.*\\.jpeg$",
  closest_genes_gex = "^scatac_closest_genes_dap_gex.*\\.jpeg$",
  closest_genes_gsea = "^scatac_closest_genes_dap_gsea.*\\.jpeg$",
  closest_genes_coverage = "^scatac_closest_genes_dap_coverage.*\\.jpeg$",
  scatac_motif = "^scatac_motif.*\\.jpeg$"
)

# Function to encode image as Base64
encode_image_to_base64 <- function(file_path) {
  image_data <- base64enc::dataURI(file = file_path, mime = "image/jpeg")
  return(image_data)
}

# Get all subfolders
subfolders <- list.dirs(path_scatac, recursive = FALSE)

# Initialize markdown content
quarto_content <- ""

# Loop through subfolders
for (subfolder in subfolders) {
  folder_name <- basename(subfolder)
  quarto_content <- paste0(quarto_content, "\n### ", folder_name, "\n\n")
  
  # Loop through patterns
  for (pattern_name in names(patterns)) {
    pattern <- patterns[[pattern_name]]
    files <- list.files(subfolder, pattern = pattern, full.names = TRUE, recursive = TRUE)
    
    if (length(files) > 0) {
      if (pattern_name == "closest_genes_coverage" || pattern_name == "closest_genes_gex" || pattern_name == "closest_genes_gsea") {
        files <- files[grepl("/closest_gene_plots/", files)]
        
        # Generate dropdown HTML for each subfolder
        select_options <- paste0(
          lapply(seq_along(files), function(i) {
            paste0("<option value='plot_", folder_name, "_", i, "'>", basename(files[i]), "</option>")
          }),
          collapse = "\n"
        )
        
        divs_content <- paste0(
          lapply(seq_along(files), function(i) {
            paste0(
              "<div id='plot_", folder_name, "_", i, "' style='display:none;'>",
              "<img src='", files[i], "' style='max-width:100%; height:auto;'>",
              "</div>"
            )
          }),
          collapse = "\n"
        )
        
        # Generate dropdown HTML and container with images
        dropdown_html <- paste0(
          "<div>\n",
          "  <label for='dropdown-", folder_name, "_", pattern_name, "'>Select a Plot:</label>\n",
          "  <select id='dropdown-", folder_name, "_", pattern_name, "'>\n",
          select_options,
          "\n  </select>\n",
          "</div>\n",
          "<div id='container-", folder_name, "_", pattern_name, "'>\n",
          divs_content,
          "\n</div>\n",
          "<script>\n",
          "  setupDropdown('dropdown-", folder_name, "_", pattern_name, "', 'container-", folder_name, "_", pattern_name, "');\n",
          "</script>\n"
        )
        
        quarto_content <- paste0(quarto_content, dropdown_html, "\n")
      } else if (pattern_name == "scatac_motif") {
        files <- files[grepl("/motif_plots/", files)]
        
        # Generate dropdown HTML for each subfolder
        select_options <- paste0(
          lapply(seq_along(files), function(i) {
            paste0("<option value='plot_", folder_name, "_", i, "'>", basename(files[i]), "</option>")
          }),
          collapse = "\n"
        )
        
        divs_content <- paste0(
          lapply(seq_along(files), function(i) {
            paste0(
              "<div id='plot_", folder_name, "_", i, "' style='display:none;'>",
              "<img src='", files[i], "' style='max-width:100%; height:auto;'>",
              "</div>"
            )
          }),
          collapse = "\n"
        )
        
        # Generate dropdown HTML and container with images
        dropdown_html <- paste0(
          "<div>\n",
          "  <label for='dropdown-", folder_name, "_", pattern_name, "'>Select a Plot:</label>\n",
          "  <select id='dropdown-", folder_name, "_", pattern_name, "'>\n",
          select_options,
          "\n  </select>\n",
          "</div>\n",
          "<div id='container-", folder_name, "_", pattern_name, "'>\n",
          divs_content,
          "\n</div>\n",
          "<script>\n",
          "  setupDropdown('dropdown-", folder_name, "_", pattern_name, "', 'container-", folder_name, "_", pattern_name, "');\n",
          "</script>\n"
        )
        
        quarto_content <- paste0(quarto_content, dropdown_html, "\n")
      } else if (pattern_name == "scatac_volcano"){
        files <- files[grepl("/volcano_plots/", files)]
        
        # Generate dropdown HTML for each subfolder
        select_options <- paste0(
          lapply(seq_along(files), function(i) {
            paste0("<option value='plot_", folder_name, "_", i, "'>", basename(files[i]), "</option>")
          }),
          collapse = "\n"
        )
        
        divs_content <- paste0(
          lapply(seq_along(files), function(i) {
            paste0(
              "<div id='plot_", folder_name, "_", i, "' style='display:none;'>",
              "<img src='", files[i], "' style='max-width:100%; height:auto;'>",
              "</div>"
            )
          }),
          collapse = "\n"
        )
        
        # Generate dropdown HTML and container with images
        dropdown_html <- paste0(
          "<div>\n",
          "  <label for='dropdown-", folder_name, "_", pattern_name, "'>Select a Plot:</label>\n",
          "  <select id='dropdown-", folder_name, "_", pattern_name, "'>\n",
          select_options,
          "\n  </select>\n",
          "</div>\n",
          "<div id='container-", folder_name, "_", pattern_name, "'>\n",
          divs_content,
          "\n</div>\n",
          "<script>\n",
          "  setupDropdown('dropdown-", folder_name, "_", pattern_name, "', 'container-", folder_name, "_", pattern_name, "');\n",
          "</script>\n"
        )
        
        quarto_content <- paste0(quarto_content, dropdown_html, "\n")
      } else {
        # For other patterns, simply add the image
        quarto_content <- paste0(quarto_content, "#### ", pattern_name, "\n\n")
        for (file in files) {
          quarto_content <- paste0(
            quarto_content,
            "<img src='", file, "' alt='", pattern_name, "' style='max-width:100%; height:auto;'>\n\n"
          )
        }
      }
    }
  }
}
```

```{r}
#| results: asis
#| echo: false

# files <- files[grepl("/commun_prob/", files)]

cat(quarto_content)
```

```{r}
#| results: asis
#| echo: false
if (dropdown_15_exists) {
  cat(glue('
  ## Single-cell GSEA
  Rather than using a pseudobulk method, escape can be used to leverage the heterigeneity of the single-cell data to perform GSEA. [UCell](https://pubmed.ncbi.nlm.nih.gov/34285779/) was used which uses a Mann-Whitney U statistic on a gene rank list. This will result in each cell getting an enrichment score for each pathway, which is why the pipeline will take much longer when this option is run.
  
  Right now the plots do not have associated statistics, but more can be found on their [vignette](https://www.borch.dev/uploads/screpertoire/articles/running_escape)
  
  ### Heatmap summary
  If the `--pathway` option was not used, it will default to choosing the top 5 pathways average normalized enrichment score, else it will show a heatmap for each of your associated pathway patterns.
  '))
}
```

```{=html}
<div id="dropdown-15-container" style="`r if (dropdown_15_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-15">Select a Special Plot:</label>
  <select id="dropdown-15">
  `r if (dropdown_15_exists) dropdown_15$select_html else ""`
</select>
  </div>
  
  <div id="container-15" style="`r if (dropdown_15_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_15_exists) dropdown_15$divs_html else ""`
</div>
  
  <script>
  setupDropdown('dropdown-15', 'container-15');
</script>
```

```{r}
#| results: asis
#| echo: false
if (dropdown_16_exists) {
  cat(glue('
  ### Geyser plots
  
  Displays the single-cell resolution of the specific pathways. The dot shows the median enrichment value, thick lines is the 66% interval summary, and the thinnest is the 95% interval summary. 
  '))
}
```
```{=html}
<div id="dropdown-16-container" style="`r if (dropdown_16_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-16">Select a Special Plot:</label>
  <select id="dropdown-16">
  `r if (dropdown_16_exists) dropdown_16$select_html else ""`
</select>
  </div>
  
  <div id="container-16" style="`r if (dropdown_16_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_16_exists) dropdown_16$divs_html else ""`
</div>
  
  <script>
  setupDropdown('dropdown-16', 'container-16');
</script>
```

```{r}
#| results: asis
#| echo: false
if (dropdown_19_exists || dropdown_23_exists) {
  cat(glue('
  ## Trajectory inference
  Assigns prediction to how cells may undergo maturation/differentiation/cellular dynamics based on their gene expression similarity
  '))
}
```

```{r}
#| results: asis
#| echo: false
if (dropdown_19_exists) {

  cat(glue('
  ### slingshot
  Uses a minimum spanning tree (MST) on a given UMAP to form the initial cluster connections.
  
  Depending on whether there is a starting celltype specified (--beginning_cluster NAME), it will run in 2 different ways
  - No start: No pseudotimes are calculated, since the direction is unknown
  - Start: The MST will be smoothed using principal curves and then each cell will have a pseudotime calculated based on their orthogonal distance from the curve
  '))
}
```

```{r}
#| results: asis
#| echo: false
if (file.exists(paste0(path_slingshot,"ti_no_start_not_smooth.jpeg"))) {
  knitr::include_graphics(paste0(path_slingshot, "ti_no_start_not_smooth.jpeg"))
} else if (file.exists(paste0(path_slingshot,"ti_start_smooth.jpeg"))) {
  knitr::include_graphics(paste0(path_slingshot, "ti_start_smooth.jpeg"))
}
```

Trajectory inference of differentially expressed genes between the given condition. Rows are genes, columns are cells, and the columns can also be split by each predicted lineage. |Log2FC| >= 2 and padj < 0.05 
```{r}
#| results: asis
#| echo: false
if(file.exists(paste0(path_slingshot,"ti_deg_between_group.jpeg"))) {
  knitr::include_graphics(paste0(path_slingshot, "ti_deg_between_group.jpeg"))
}
```

Differentially expressed genes for across pseudotime values calculated by slingshot. Only the 50 genes are listed max in the heatmap. |Log2FC| >= 2 and padj < 0.05

```{=html}
<div id="dropdown-19-container" style="`r if (dropdown_19_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-19">Select a Special Plot:</label>
  <select id="dropdown-19">
  `r if (dropdown_19_exists) dropdown_19$select_html else ""`
</select>
  </div>
  
  <div id="container-19" style="`r if (dropdown_19_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_19_exists) dropdown_19$divs_html else ""`
</div>
  
  <script>
  setupDropdown('dropdown-19', 'container-19');
</script>
```
```{r}
#| results: asis
#| echo: false
if (dropdown_23_exists) {
  cat(glue('
  ### psupertime
  Identifies ordering coefficients for each genes, where the value is equal to the contribution the gene has to cell ordering (based on their sequential expression). This coefficient is multipled with the gene expression matrix to get the pseudotime values for each cell. It requires to have a time condition/variable via `--main_time true` or `--co_conditions time`
  '))
}
```

Showing distribution of psupertimes for a given cluster label for each timepoint. T-test performed for significance test
```{=html}
<div id="dropdown-23-container" style="`r if (dropdown_23_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-23">Select a Special Plot:</label>
  <select id="dropdown-23">
  `r if (dropdown_23_exists) dropdown_23$select_html else ""`
</select>
  </div>
  
  <div id="container-23" style="`r if (dropdown_23_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_23_exists) dropdown_23$divs_html else ""`
</div>
  
  <script>
  setupDropdown('dropdown-23', 'container-23');
</script>
```
```{r}
#| results: asis
#| echo: false
if (dropdown_26_exists) {
  cat(glue('
  ## Differential Abundance
  Detects changes in compositions between multicondition scRNA-seq datasets.
  '))
}
```

Uncorrected P-value distribution, should have a right skew (anti-conservative) distribution
```{=html}
<div id="dropdown-24-container" style="`r if (dropdown_24_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-24">Select a Special Plot:</label>
  <select id="dropdown-24">
  `r if (dropdown_24_exists) dropdown_24$select_html else ""`
</select>
  </div>
  
  <div id="container-24" style="`r if (dropdown_24_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_24_exists) dropdown_24$divs_html else ""`
</div>
  
  <script>
  setupDropdown('dropdown-24', 'container-24');
</script>
```

Visualizes the the SpatialFDR values to quickly see if any neighbourhoods make the cutoff
```{=html}
<div id="dropdown-25-container" style="`r if (dropdown_25_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-25">Select a Special Plot:</label>
  <select id="dropdown-25">
  `r if (dropdown_25_exists) dropdown_25$select_html else ""`
</select>
  </div>
  
  <div id="container-25" style="`r if (dropdown_25_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_25_exists) dropdown_25$divs_html else ""`
</div>
  
  <script>
  setupDropdown('dropdown-25', 'container-25');
</script>
```

Single-cell clustered UMAP from Seurat, where each point is now gathered into neighbourhoods, edges show shared cells between neighrbourhoods, and colour is the logFC value from testNhoods
```{=html}
<div id="dropdown-26-container" style="`r if (dropdown_26_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-26">Select a Special Plot:</label>
  <select id="dropdown-26">
  `r if (dropdown_26_exists) dropdown_26$select_html else ""`
</select>
  </div>
  
  <div id="container-26" style="`r if (dropdown_26_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_26_exists) dropdown_26$divs_html else ""`
</div>
  
  <script>
  setupDropdown('dropdown-26', 'container-26');
</script>
```

Beeswarm plot showing fold-change distribution 
```{=html}
<div id="dropdown-27-container" style="`r if (dropdown_27_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-27">Select a Special Plot:</label>
  <select id="dropdown-27">
  `r if (dropdown_27_exists) dropdown_27$select_html else ""`
</select>
  </div>
  
  <div id="container-27" style="`r if (dropdown_27_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_27_exists) dropdown_27$divs_html else ""`
</div>
  
  <script>
  setupDropdown('dropdown-27', 'container-27');
</script>
```

Differentially expressed genes that meet a differential abundance cutoff between conditions; logFC used to determine if a gene is differentially expressed is from using da_CLUSTER_markers_avg_logfc_GROUPING 'avg_logFC' value
```{=html}
<div id="dropdown-28-container" style="`r if (dropdown_28_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-28">Select a Special Plot:</label>
  <select id="dropdown-28">
  `r if (dropdown_28_exists) dropdown_28$select_html else ""`
</select>
  </div>
  
  <div id="container-28" style="`r if (dropdown_28_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_28_exists) dropdown_28$divs_html else ""`
</div>
  
  <script>
  setupDropdown('dropdown-28', 'container-28');
</script>
```

GSEA results that uses the da_CLUSTER_markers_avg_logfc_GROUPING 'avg_logFC' values as a ranked list.
```{=html}
<div id="dropdown-29-container" style="`r if (dropdown_29_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-29">Select a Special Plot:</label>
  <select id="dropdown-29">
  `r if (dropdown_29_exists) dropdown_29$select_html else ""`
</select>
  </div>
  
  <div id="container-29" style="`r if (dropdown_29_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_29_exists) dropdown_29$divs_html else ""`
</div>
  
  <script>
  setupDropdown('dropdown-29', 'container-29');
</script>
```

```{r}
#| results: asis
#| echo: false
path_cellchat <- paste0(res.loc, "/plots/cellchat_plots/")

if (dir.exists(path_cellchat)) {
  cat(glue('
  ## Cellchat
  CellChat identifies and quantifies interatctions between cells based on the expression of ligands and their corresponding receptors
  
  Finding over-expressed ligand-receptor pairs and pathways using a communication probability
  - https://htmlpreview.github.io/?https://github.com/jinworks/CellChat/blob/master/tutorial/CellChat-vignette.html
  - Communication probability is built off gene expression, the ligand-receptor interactions from the curated CellChat database, and law of mass action
    - Genes are chosen if they are overexpressed ligands and/or receptors
  - Significant cell-cell communication is calculated by performing a permutation test on the communication probability
  
  ### Plot descriptions
  - <ins>interaction_summary_bar:</ins> Compares total number of interactions and strength of the cell-cell communication networks
  - <ins>differential_interaction_circle:</ins> Red colored edges show increased signaling in the second dataset (Sorted it lexicographical order). Size of the edge represents the differential number of interactions/strength
  - <ins>differential_interaction_heatmap:</ins> Red show increased signaling in the second dataset (Sorted it lexicographical order). Top bar plot = Incoming signal for the given cell group; Right bar plot = Outgoing signal for the given cell group
  - <ins>num_interactions_circle:</ins> Shows the number of interactions between the different cell groups
  - <ins>population_send_receive:</ins> Identifying cell populations with significant changes in sending/receiving signals
  - <ins>compare_all_signal_heatmap:</ins> Aggregated heatmap of outgoing and incoming signals
  - <ins>information_flow_compare:</ins> Information flow = sum of the communication probability amoung all pairs of cell groups in the pathway, or known as total weight of the network. Highlighted pathways display the significant pathways according to a paired Wilcoxon test.
    - <ins>expression:</ins> Shows the different expression of genes involved in the given pathway, if found in the dataset
    - <ins>signal_path:</ins> Shows which cells are involved in the given PATHWAY. The inner thinner bars reprsent the target cell that receive the signal, and the size is proportional to the signal strength received
  - <ins>commun_prob_expression:</ins> Comparing communication probabilities from different ligand-receptor pairs. Each column is cell-cell specific, and the different colors represent the condition. If the title of the plot does not show "Unfiltered" that means the communication probability difference between two cell-cell for the two different conditions is ~50%
  '))
}
```

```{r}
#| echo: false

# Base directory
path_cellchat <- paste0(res.loc, "/plots/cellchat_plots/")

# Patterns
patterns <- list(
  interaction_summary_bar = "\\_interaction_summary_bar.jpeg$",
  differential_interaction_circle = "\\_differential_interaction_circle.jpeg$",
  differential_interaction_heatmap = "\\_differential_interaction_heatmap.jpeg$",
  num_interactions_circle = "\\_num_interactions_circle.jpeg$",
  population_send_receive = "\\_population_send_receive.jpeg$",
  compare_all_signal_heatmap = "\\_compare_all_signal_heatmap.jpeg$",
  info_flow = "\\_information_flow_compare.jpeg$", 
  signaling_pathways_expression = "\\_expression.jpeg$",
  signal_path = "\\_signal_path.jpeg$",
  commun_prob_expression = "\\_expression.jpeg$"
)

# Function to encode image as Base64
encode_image_to_base64 <- function(file_path) {
  image_data <- base64enc::dataURI(file = file_path, mime = "image/jpeg")
  return(image_data)
}

# Get all subfolders
subfolders <- list.dirs(path_cellchat, recursive = FALSE)

# Initialize markdown content
quarto_content <- ""

# Loop through subfolders
for (subfolder in subfolders) {
  folder_name <- basename(subfolder)
  quarto_content <- paste0(quarto_content, "\n### ", folder_name, "\n\n")
  
  # Loop through patterns
  for (pattern_name in names(patterns)) {
    pattern <- patterns[[pattern_name]]
    files <- list.files(subfolder, pattern = pattern, full.names = TRUE, recursive = TRUE)
    
    if (length(files) > 0) {
      if (pattern_name == "commun_prob_expression") {
        files <- files[grepl("/commun_prob/", files)]
        
        # Generate dropdown HTML for each subfolder
        select_options <- paste0(
          lapply(seq_along(files), function(i) {
            paste0("<option value='plot_", folder_name, "_", i, "'>", basename(files[i]), "</option>")
          }),
          collapse = "\n"
        )
        
        divs_content <- paste0(
          lapply(seq_along(files), function(i) {
            paste0(
              "<div id='plot_", folder_name, "_", i, "' style='display:none;'>",
              "<img src='", files[i], "' style='max-width:100%; height:auto;'>",
              "</div>"
            )
          }),
          collapse = "\n"
        )
        
        # Generate dropdown HTML and container with images
        dropdown_html <- paste0(
          "#### ", pattern_name, "\n\n",
          "<div>\n",
          "  <label for='dropdown-", folder_name, "_", pattern_name, "'>Select a Plot:</label>\n",
          "  <select id='dropdown-", folder_name, "_", pattern_name, "'>\n",
          select_options,
          "\n  </select>\n",
          "</div>\n",
          "<div id='container-", folder_name, "_", pattern_name, "'>\n",
          divs_content,
          "\n</div>\n",
          "<script>\n",
          "  setupDropdown('dropdown-", folder_name, "_", pattern_name, "', 'container-", folder_name, "_", pattern_name, "');\n",
          "</script>\n"
        )
        
        quarto_content <- paste0(quarto_content, dropdown_html, "\n")
      } else if (pattern_name == "signaling_pathways_expression") {
        files <- files[grepl("/signaling_pathways/", files)]
        
        # Generate dropdown HTML for each subfolder
        select_options <- paste0(
          lapply(seq_along(files), function(i) {
            paste0("<option value='plot_", folder_name, "_", i, "'>", basename(files[i]), "</option>")
          }),
          collapse = "\n"
        )
        
        divs_content <- paste0(
          lapply(seq_along(files), function(i) {
            paste0(
              "<div id='plot_", folder_name, "_", i, "' style='display:none;'>",
              "<img src='", files[i], "' style='max-width:100%; height:auto;'>",
              "</div>"
            )
          }),
          collapse = "\n"
        )
        
        # Generate dropdown HTML and container with images
        dropdown_html <- paste0(
          "#### ", pattern_name, "\n\n",
          "<div>\n",
          "  <label for='dropdown-", folder_name, "_", pattern_name, "'>Select a Plot:</label>\n",
          "  <select id='dropdown-", folder_name, "_", pattern_name, "'>\n",
          select_options,
          "\n  </select>\n",
          "</div>\n",
          "<div id='container-", folder_name, "_", pattern_name, "'>\n",
          divs_content,
          "\n</div>\n",
          "<script>\n",
          "  setupDropdown('dropdown-", folder_name, "_", pattern_name, "', 'container-", folder_name, "_", pattern_name, "');\n",
          "</script>\n"
        )
        
        quarto_content <- paste0(quarto_content, dropdown_html, "\n")
      } else if (pattern_name == "signal_path"){
        files <- files[grepl("/signaling_pathways/", files)]
        
        # Generate dropdown HTML for each subfolder
        select_options <- paste0(
          lapply(seq_along(files), function(i) {
            paste0("<option value='plot_", folder_name, "_", i, "'>", basename(files[i]), "</option>")
          }),
          collapse = "\n"
        )
        
        divs_content <- paste0(
          lapply(seq_along(files), function(i) {
            paste0(
              "<div id='plot_", folder_name, "_", i, "' style='display:none;'>",
              "<img src='", files[i], "' style='max-width:100%; height:auto;'>",
              "</div>"
            )
          }),
          collapse = "\n"
        )
        
        # Generate dropdown HTML and container with images
        dropdown_html <- paste0(
          "#### ", pattern_name, "\n\n",
          "<div>\n",
          "  <label for='dropdown-", folder_name, "_", pattern_name, "'>Select a Plot:</label>\n",
          "  <select id='dropdown-", folder_name, "_", pattern_name, "'>\n",
          select_options,
          "\n  </select>\n",
          "</div>\n",
          "<div id='container-", folder_name, "_", pattern_name, "'>\n",
          divs_content,
          "\n</div>\n",
          "<script>\n",
          "  setupDropdown('dropdown-", folder_name, "_", pattern_name, "', 'container-", folder_name, "_", pattern_name, "');\n",
          "</script>\n"
        )
        
        quarto_content <- paste0(quarto_content, dropdown_html, "\n")
      } else {
        # For other patterns, simply add the image
        quarto_content <- paste0(quarto_content, "#### ", pattern_name, "\n\n")
        for (file in files) {
          quarto_content <- paste0(
            quarto_content,
            "<img src='", file, "' alt='", pattern_name, "' style='max-width:100%; height:auto;'>\n\n"
          )
        }
      }
    }
  }
}
```

```{r}
#| results: asis
#| echo: false

cat(quarto_content)
```

```{r}
#| results: asis
#| echo: false
if (dropdown_30_exists) {
  cat(glue('
  ## Neuroestimator
  Predicts a neural activty score using an autoencoder (neural network) based off 22 well-established neuronal activity markers. Kolmogorov–Smirnov (KS) test was used to compare distributions. 
  '))
}
```

```{=html}
<div id="dropdown-30-container" style="`r if (dropdown_30_exists) "display: block;" else "display: none;"`">
  <label for="dropdown-30">Select a Special Plot:</label>
  <select id="dropdown-30">
  `r if (dropdown_30_exists) dropdown_30$select_html else ""`
</select>
  </div>
  
  <div id="container-30" style="`r if (dropdown_30_exists) "display: block;" else "display: none;"`">
  `r if (dropdown_30_exists) dropdown_30$divs_html else ""`
</div>
  
  <script>
  setupDropdown('dropdown-30', 'container-30');
</script>
```
